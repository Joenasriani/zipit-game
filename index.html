<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZIP IT! - Robomarket</title>
    <script src="https://cdn.tailwindcss.com/"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            background-color: rgb(248, 250, 255);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            user-select: none;
            margin: 0;
            padding: 0;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }
        @keyframes zipPop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes iconPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.35); }
            100% { transform: scale(1); }
        }
        .shake-board { animation: shake 0.2s ease-in-out 3; border-color: rgb(239, 68, 68) !important; }
        .flash-red { background-color: rgba(239, 68, 68, 0.1) !important; }
        .animate-zip-pop { animation: zipPop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        .animate-icon-click { animation: iconPop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        .responsive-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 2vh 0;
        }
        .game-board-wrapper {
            width: 90vmin;
            height: 90vmin;
            max-width: 580px;
            max-height: 580px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const LEVELS = [
            { size: 6, nodes: { "0,0": 1, "5,0": 2, "5,5": 3, "5,4": 4 } },
            { size: 6, nodes: { "0,0": 1, "5,0": 2, "5,5": 3, "4,5": 4, "0,5": 5 } },
            { size: 6, nodes: { "1,1": 1, "4,1": 2, "4,4": 3, "1,4": 4, "0,5": 5 } },
            { size: 6, nodes: { "0,0": 1, "5,5": 2, "3,5": 3, "0,5": 4 } }, // Fixed L4: Moved 3 from (5,0) to (3,5)
            { size: 6, nodes: { "1,1": 1, "1,4": 2, "4,4": 3, "4,1": 4, "0,1": 5 } },
            { size: 6, nodes: { "0,0": 1, "2,2": 2, "4,4": 3, "5,5": 4, "5,4": 5 } },
            { size: 6, nodes: { "1,1": 1, "1,4": 2, "4,4": 3, "4,1": 4, "2,2": 5, "2,3": 6, "3,3": 7, "3,2": 8, "0,1": 9 } },
            { size: 6, nodes: { "3,3": 1, "0,0": 2, "0,5": 3, "5,4": 4 } },
            { size: 6, nodes: { "0,0": 1, "5,5": 2, "5,0": 3, "0,5": 4, "2,2": 5, "3,2": 6, "5,2": 7 } },
            { size: 6, nodes: { "1,1": 1, "2,2": 2, "3,3": 3, "4,4": 4, "1,4": 5, "4,1": 6, "0,1": 7 } },
            { size: 6, nodes: { "0,0": 1, "0,1": 2, "0,2": 3, "0,3": 4, "0,4": 5, "0,5": 6, "5,5": 7, "5,4": 8, "4,5": 9 } },
            { size: 6, nodes: { "1,1": 1, "1,2": 2, "2,2": 3, "2,1": 4, "3,1": 5, "3,2": 6, "4,2": 7, "4,1": 8, "5,0": 9, "5,1": 10, "5,2": 11 } },
            { size: 6, nodes: { "0,0": 1, "5,0": 2, "5,5": 3, "0,5": 4, "3,3": 5, "2,2": 6, "1,1": 7, "4,3": 8, "5,4": 9 } },
            { size: 6, nodes: { "0,0": 1, "3,0": 2, "3,3": 3, "0,3": 4, "0,5": 5, "5,5": 6, "5,0": 7, "2,2": 8, "4,5": 9, "5,4": 10 } },
            { size: 6, nodes: { "1,1": 1, "1,4": 2, "4,4": 3, "4,1": 4, "2,2": 5, "2,3": 6, "3,3": 7, "3,2": 8, "0,0": 9, "5,4": 10, "0,5": 11 } },
            { size: 6, nodes: { "0,0": 1, "0,5": 2, "1,5": 3, "1,0": 4, "2,0": 5, "2,5": 6, "3,5": 7, "3,0": 8, "4,0": 9, "4,5": 10, "5,4": 11 } },
            { size: 6, nodes: { "0,0": 1, "1,1": 3, "0,1": 2, "1,0": 4, "2,0": 5, "2,1": 6, "3,1": 7, "3,0": 8, "5,0": 9, "5,5": 10, "0,3": 11, "5,4": 12 } },
            { size: 6, nodes: { "0,0": 1, "2,0": 2, "2,2": 3, "0,2": 4, "0,4": 5, "2,4": 6, "4,4": 7, "4,2": 8, "4,0": 9, "5,5": 10, "3,2": 11, "5,4": 12 } },
            { size: 6, nodes: { "0,0": 1, "0,1": 2, "1,1": 3, "1,0": 4, "2,0": 5, "2,1": 6, "3,1": 7, "3,0": 8, "4,0": 9, "4,1": 10, "5,1": 11, "5,0": 12, "5,3": 13, "0,5": 14 } },
            { size: 6, nodes: { "0,0": 1, "1,0": 2, "1,1": 3, "0,1": 4, "0,2": 5, "1,2": 6, "1,3": 7, "0,3": 8, "0,4": 9, "1,4": 10, "1,5": 11, "0,5": 12, "5,5": 13, "5,4": 14, "4,5": 15 } }
        ];

        const COMP_MESSAGES = [
            "So you know how to zip it.", Ok! Nice one.", 
            "Clean start.", "Nice.", "Ok! Nice too.", 
            "Okay, that was clean.", "You’re getting it.", "Not bad at all.", "Nice. Don’t get comfortable.", "You’re warming up. Joe noticed.",
            "That wasn’t accidental.", "You’re thinking ahead now.", "Most people mess this up.", "Feeling confident yet?", "That path had intent.",
            "Okay… that was smart.", "You saw the trap.", "Logic over luck. Good choice.", "You’re not guessing anymore.", "That filtered the amateurs."
        ];

        const SpeakerOn = () => (
            <svg key="on" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className="text-[rgb(0,65,130)]"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path></svg>
        );
        const SpeakerOff = () => (
            <svg key="off" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
        );

        function App() {
            const [levelIdx, setLevelIdx] = useState(0);
            const [path, setPath] = useState([]);
            const [isDragging, setIsDragging] = useState(false);
            const [win, setWin] = useState(false);
            const [errorCell, setErrorCell] = useState(null);
            const [isMusicOn, setIsMusicOn] = useState(false);
            const [shake, setShake] = useState(false);
            const [isAnimatingIcon, setIsAnimatingIcon] = useState(false);
            
            const canvasRef = useRef(null);
            const gridRef = useRef(null);
            const audioRef = useRef(null);

            const currentLevel = LEVELS[levelIdx];
            const maxVal = useMemo(() => Math.max(...Object.values(currentLevel.nodes)), [currentLevel]);

            useEffect(() => {
                if (!audioRef.current) {
                    audioRef.current = new Audio('music/zipit.mp3');
                    audioRef.current.loop = true;
                }
                if (isMusicOn) audioRef.current.play().catch(() => {});
                else audioRef.current.pause();
            }, [isMusicOn]);

            const toggleMusic = () => {
                setIsMusicOn(!isMusicOn);
                setIsAnimatingIcon(true);
                setTimeout(() => setIsAnimatingIcon(false), 300);
            };

            const drawPath = () => {
                const canvas = canvasRef.current;
                if (!canvas || !gridRef.current) return;
                const ctx = canvas.getContext('2d');
                const rect = gridRef.current.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, rect.width, rect.height);

                if (path.length < 1) return;
                const cellSize = rect.width / currentLevel.size;
                const half = cellSize / 2;

                ctx.beginPath();
                ctx.strokeStyle = 'rgb(230, 138, 62)'; 
                ctx.lineWidth = cellSize * 0.75; 
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                path.forEach((pos, i) => {
                    const x = pos.c * cellSize + half;
                    const y = pos.r * cellSize + half;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                if (path.length > 0) {
                    const head = path[path.length - 1];
                    ctx.beginPath();
                    ctx.fillStyle = 'white';
                    ctx.arc(head.c * cellSize + half, head.r * cellSize + half, cellSize * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            };

            useEffect(() => {
                drawPath();
                window.addEventListener('resize', drawPath);
                return () => window.removeEventListener('resize', drawPath);
            }, [path, levelIdx]);

            const getCoords = (clientX, clientY) => {
                if (!gridRef.current) return null;
                const rect = gridRef.current.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                if (x < 0 || x > rect.width || y < 0 || y > rect.height) return null;
                const c = Math.floor((x / rect.width) * currentLevel.size);
                const r = Math.floor((y / rect.height) * currentLevel.size);
                return { r, c };
            };

            const handlePointerDown = (e) => {
                if (win) return;
                const coords = getCoords(e.clientX, e.clientY);
                if (!coords) return;
                const key = `${coords.r},${coords.c}`;
                if (path.length === 0) {
                    if (currentLevel.nodes[key] === 1) {
                        setPath([coords]);
                        setIsDragging(true);
                    }
                } else {
                    const idx = path.findIndex(p => p.r === coords.r && p.c === coords.c);
                    if (idx !== -1) {
                        setPath(path.slice(0, idx + 1));
                        setIsDragging(true);
                    }
                }
            };

            const handlePointerMove = (e) => {
                if (!isDragging || win) return;
                const coords = getCoords(e.clientX, e.clientY);
                if (!coords) return;
                
                const headNode = path[path.length - 1];
                if (headNode.r === coords.r && headNode.c === coords.c) return;

                if (Math.abs(coords.r - headNode.r) + Math.abs(coords.c - headNode.c) === 1) {
                    if (path.length > 1) {
                        const prev = path[path.length - 2];
                        if (prev.r === coords.r && prev.c === coords.c) {
                            setPath(path.slice(0, -1));
                            return;
                        }
                    }
                    if (path.some(p => p.r === coords.r && p.c === coords.c)) return;
                    
                    const nodeVal = currentLevel.nodes[`${coords.r},${coords.c}`];
                    if (nodeVal) {
                        let last = 0;
                        for (let i = path.length - 1; i >= 0; i--) {
                            const v = currentLevel.nodes[`${path[i].r},${path[i].c}`];
                            if (v) { last = v; break; }
                        }
                        if (nodeVal !== last + 1) {
                            setErrorCell(coords);
                            setTimeout(() => setErrorCell(null), 250);
                            return;
                        }
                    }
                    const newPath = [...path, coords];
                    setPath(newPath);

                    const total = currentLevel.size * currentLevel.size;
                    const endVal = currentLevel.nodes[`${coords.r},${coords.c}`];

                    if (newPath.length === total && endVal === maxVal) {
                        setWin(true);
                        setIsDragging(false);
                        setTimeout(() => {
                            if (levelIdx < LEVELS.length - 1) {
                                setLevelIdx(prev => prev + 1);
                                setPath([]);
                                setWin(false);
                            }
                        }, 3000);
                    } else if (endVal === maxVal) {
                        setShake(true);
                        setErrorCell(coords);
                        setTimeout(() => { setShake(false); setErrorCell(null); }, 600);
                    }
                }
            };

            return (
                <div className="responsive-container">
                    <div className="w-full max-w-[800px] flex justify-between items-center px-6 shrink-0 h-20">
                        <div className="flex flex-col text-left">
                            <div className="flex items-center gap-1.5 uppercase tracking-tighter">
                                <span className="bg-blue-900 text-white px-2.5 py-1 rounded-md text-3xl font-black" style={{backgroundColor: 'rgb(0, 65, 130)'}}>ZIP</span>
                                <span className="text-4xl font-black text-gray-800">IT!</span>
                            </div>
                            <span className="text-[10px] text-gray-400 font-bold tracking-tight uppercase text-left">LINKEDIN GAME PRACTICE</span>
                        </div>
                        <div className="flex gap-5 items-center">
                            <button onClick={() => setPath([])} className="text-gray-500 font-bold bg-gray-200/60 px-6 py-2 rounded-full text-sm border border-gray-300 active:bg-gray-300">Clear</button>
                            <div 
                                onClick={toggleMusic} 
                                className={`cursor-pointer transition-transform ${isAnimatingIcon ? 'animate-icon-click' : ''}`}
                            >
                                {isMusicOn ? <SpeakerOn /> : <SpeakerOff />}
                            </div>
                        </div>
                    </div>

                    <div className="game-board-wrapper flex items-center justify-center p-4">
                        <div className={`bg-white border-[4px] border-gray-300 rounded-[48px] p-2 shadow-md transition-all ${shake ? 'shake-board' : ''} w-full h-full aspect-square`}>
                            <div ref={gridRef} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={() => setIsDragging(false)} className="relative w-full h-full overflow-hidden rounded-[38px] grid grid-cols-6 grid-rows-6">
                                <canvas ref={canvasRef} className="absolute inset-0 z-10 pointer-events-none" style={{ width: '100%', height: '100%' }} />
                                {Array.from({ length: 36 }).map((_, i) => {
                                    const r = Math.floor(i / 6), c = i % 6;
                                    const val = currentLevel.nodes[`${r},${c}`];
                                    const isInPath = path.some(p => p.r === r && p.c === c);
                                    const isError = errorCell?.r === r && errorCell?.c === c;
                                    const nodeBg = val ? (isInPath ? 'rgb(0, 65, 130)' : 'black') : 'transparent';
                                    const isMissed = shake && !isInPath;

                                    return (
                                        <div key={i} className={`relative flex items-center justify-center border-[0.5px] border-gray-100 transition-colors ${isMissed ? 'flash-red' : ''}`}>
                                            {val && (
                                                <div className={`w-[74%] h-[74%] rounded-full flex items-center justify-center font-bold text-xl z-20 transition-all text-white ${isError ? 'bg-red-500 scale-110' : ''}`} style={{backgroundColor: nodeBg}}>
                                                    {val}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>

                    <div className="w-full max-w-[600px] px-6 shrink-0 flex flex-col justify-center gap-4">
                        <button disabled={path.length < 2 || win} onClick={() => setPath(prev => prev.slice(0, -1))} className="w-full bg-gray-200 text-gray-500 font-bold py-5 rounded-full text-xl active:bg-gray-300 transition-colors shadow-sm disabled:opacity-50">Undo</button>
                    </div>

                    <div className="flex-grow flex items-end pb-6">
                        <div className="text-center font-black text-gray-400 text-xs uppercase tracking-widest">Level {levelIdx + 1} of 20</div>
                    </div>

                    {win && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center p-8 bg-white/40 backdrop-blur-[6px] transition-opacity duration-300 opacity-100">
                            <div className="bg-white rounded-[40px] p-10 text-center max-sm shadow-2xl border-4 border-[rgb(0,65,130)] animate-zip-pop">
                                <h2 className="text-6xl font-black text-[rgb(0,65,130)] mb-2 italic uppercase tracking-tighter text-left ml-4">ZIPPED!</h2>
                                <p className="text-gray-600 font-black text-lg leading-snug">{COMP_MESSAGES[levelIdx]}</p>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

